# Snake AI - Groupe 09

## Implémentation avec Algorithmes de Pathfinding

### Timeline du Projet

> **Note importante :** Cette timeline concerne uniquement la **partie Algorithmes** (BFS, Dijkstra, Algorithme Maison).  
> La **partie IA/Machine Learning** (implémentée en parallèle avec un camarade) suit une timeline différente et n'est pas encore documentée ici.

---

### Timeline - Partie Algorithmes

**Phase 1 : Conception et Implémentation des Algorithmes Classiques (19h40 - 20h00)**

- Étude du jeu de base `serpent.py`
- Implémentation de **BFS** (Breadth-First Search)
- Implémentation de **Dijkstra** avec priority queue
- Interface de sélection d'algorithmes (touches 1-4)
- Tests et comparaisons de performances

**Phase 2 : Développement de l'Algorithme Maison - V1 (20h00 - 20h15)**

- Création d'un algorithme hybride basé sur Hamilton Cycle avec raccourcis
- Implémentation de la sécurité de base (`can_reach_tail`)
- Premiers tests : le serpent atteint ~118 pommes mais se bloque

**Phase 3 : Optimisations de Sécurité - V2.0 à V2.2 (20h15 - 20h45)**

- **V2.0** : Ajout de `count_accessible_spaces()` pour évaluer l'espace disponible
- **V2.1** : Correction du suivi de queue (éviter de suivre quand trop proche)
- **V2.2** : Implémentation du lookahead (vérification à 2 coups d'avance)
- Amélioration progressive mais blocages persistants

**Phase 4 : Système Adaptatif Multi-Modes - V2.3 à V2.4 (20h45 - 21h15)**

- **V2.3** : Création d'un système à 4 modes adaptatifs basés sur le taux de remplissage
  - Mode Agressif (0-40%)
  - Mode Équilibré (40-60%)
  - Mode Prudent (60-75%)
  - Mode Survie (75%+)
- **V2.4** : Premier ajustement des seuils (survie à 65%)
- Résultat : le serpent tourne en rond trop longtemps en mode survie

**Phase 5 : Optimisation Fine des Seuils - V2.5 à V2.6 (21h15 - 21h45)**

- **V2.5** : Repousse le mode survie à 72%, ajustement des min_space_ratio
- **V2.5.1** : Assouplissement du mode équilibré (0.32 → 0.28)
- **V2.6** : Optimisation maximum - survie repoussée à 78%
  - Tous les modes assouplis pour croissance ultra-rapide
  - Tentatives multiples pour trouver l'équilibre parfait vitesse/sécurité
  - Ajustements fin de tous les paramètres (min_space_ratio, conservation d'espace, etc.)

**Résultat Final :**

Après de nombreux tests et ajustements sur environ 30 minutes, l'algorithme maison atteint ses limites avec un **score d'environ 170 pommes en 4 minutes**. Le compromis entre vitesse et sécurité est délicat à optimiser davantage sans risquer des blocages.

### Utilisation

**Lancement du jeu :**

```bash
python snake-algo.py
```

**Contrôles :**

- `1` : Mode BFS (Breadth-First Search)
- `2` : Mode Dijkstra
- `3` : Mode Hamilton optimisé (par défaut)
- `4` : Mode Manuel
- `Flèches` : Contrôle manuel (en mode 4)
- `ESPACE` : Rejouer après Game Over

### Algorithmes Implémentés

#### 1. BFS (Breadth-First Search)

**Principe :** Explore tous les chemins niveau par niveau pour trouver le plus court chemin vers la pomme.

**Avantages :**

- Trouve toujours le chemin le plus court
- Simple et efficace pour petites grilles
- Bon pour comprendre le pathfinding de base

**Inconvénients :**

- Peut se piéger dans des situations sans issue
- Ne garantit pas la survie à long terme
- Adapté pour démonstration mais pas optimal

#### 2. Dijkstra

**Principe :** Variante de BFS avec gestion des coûts. Dans notre cas, tous les coûts sont égaux (1 par case).

**Avantages :**

- Extensible pour coûts variables
- Pathfinding optimal
- Base pour A* (avec heuristique)

**Inconvénients :**

- Performance similaire à BFS dans notre cas
- Plus complexe sans bénéfice majeur ici
- Peut aussi se piéger

#### 3. Algorithme Maison - Hamilton Cycle Adaptatif

**Principe :** Algorithme hybride basé sur les concepts de Hamilton Cycle, A*, et BFS avec un système adaptatif à 4 modes selon le taux de remplissage de la grille.

**Stratégie Multi-Modes :**

1. **Mode Agressif (0-35%)** : Croissance ultra-rapide vers la pomme
2. **Mode Équilibré (35-60%)** : Balance entre vitesse et sécurité
3. **Mode Prudent (60-78%)** : Sécurité renforcée avec vérifications strictes
4. **Mode Survie (78%+)** : Suivi de queue en boucle serrée

**Mécanismes de Sécurité :**

- **Lookahead à 2 coups** : Vérifie qu'il y a toujours une sortie après le prochain mouvement
- **Count accessible spaces** : BFS pour compter l'espace accessible après chaque mouvement
- **Can reach tail** : Garantit qu'on peut toujours rejoindre sa queue
- **Min space ratio dynamique** : Ajusté selon le mode (0.22 à 0.42)

**Performance :**

- **Score moyen : ~170 pommes en 4 minutes** (grille 15x15 = 224 max)
- Compromis optimal entre vitesse et sécurité trouvé après de nombreux ajustements
- Système adaptatif qui change de stratégie selon la phase de jeu

### Comparaison des Performances

| Algorithme         | Approche          | Points Forts              | Vitesse |
|--------------------|-------------------|---------------------------|---------|
| BFS                | Pathfinding simple| Simple, chemin le plus court | ⚡⚡⚡|
| Dijkstra           | Coûts uniformes   | Extensible, optimal       | ⚡⚡   |
| **Algo Maison**    | **Hybride adaptatif** | **~170 en 4min, sécurisé** | ⚡⚡   |

### Concepts Techniques

**Can Reach Tail (Fonction Clé) :**

```python
def can_reach_tail(start, snake_body):
    """
    Vérifie si on peut atteindre la queue après avoir mangé.
    Évite de se piéger dans un cul-de-sac.
    """
```

Cette fonction est cruciale pour l'algorithme Hamilton. Elle simule le mouvement et vérifie qu'un chemin existe toujours vers la queue, garantissant qu'on ne se bloque jamais.

**Follow Tail (Stratégie de Survie) :**

```python
def follow_tail(snake):
    """
    Suit la queue du serpent - ultra sûr.
    Si impossible d'atteindre la pomme en sécurité,
    on tourne en rond en suivant notre queue.
    """
```

### Philosophie de l'Algorithme Maison

L'objectif était de créer un algorithme qui trouve le meilleur équilibre entre **vitesse** et **sécurité** :

1. **Adaptation dynamique** : Change de stratégie selon le taux de remplissage
2. **Sécurité multicouche** : Lookahead, espace accessible, vérification de queue
3. **Optimisation itérative** : Ajustement fin des seuils après de nombreux tests
4. **Compromis assumé** : ~170 pommes en 4min représente une limite pratique

**Limites rencontrées :**

Après environ 30 minutes d'ajustements fins des seuils (V2.3 → V2.6), l'algorithme atteint ses limites. Pousser plus loin l'agressivité risque des blocages, tandis que trop de prudence ralentit excessivement la progression.

### Références

- Document "Reinforcement Learning.pdf" (Groupe 09)
- serpent.py (Jeu de base)
- Algorithmes de graphes : BFS, Dijkstra, A*
- Hamiltonian Path problem (NP-complet)

### Améliorations Futures

Pour dépasser les limites actuelles :

1. **Machine Learning** : Q-Learning ou Deep Q-Network pour apprendre les seuils optimaux
2. **Simulation Monte Carlo** : Tester des milliers de combinaisons de seuils automatiquement
3. **Hamiltonian précalculé** : Utiliser un vrai cycle hamiltonien optimal pour la grille
4. **Lookahead plus profond** : Analyser 3-4 coups à l'avance (coût computationnel élevé)
5. **Heuristiques avancées** : Détection de patterns dangereux spécifiques
